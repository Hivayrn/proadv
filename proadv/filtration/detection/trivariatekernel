import numpy as np
from scipy import linalg
from scipy.stats._stats import gaussian_kernel_estimate as gke
from scipy.stats import gaussian_kde as kde

def _derivatives(data):

    dc = np.zeros_like(data)
    dc2 = np.zeros_like(data)

    for i in range(1, data.size - 1):
        dc[i] = (data[i + 1] - data[i - 1]) / 2

    for i in range(1, data.size - 1):
        dc2[i] = (dc[i + 1] - dc[i - 1]) / 2

    return dc, dc2


def _rotation(u1, w1):

    data_size = u1.size

    theta = np.arctan2((data_size * np.sum(u1 * w1) - np.sum(u1) * np.sum(w1)),
                       (data_size * np.sum(u1 * u1) - np.sum(u1) * np.sum(u1)))
    
    return theta


def _transform(x, y, theta):

    xt = x * np.cos(theta) + y * np.sin(theta)

    yt = -x * np.sin(theta) + y * np.cos(theta)

    return xt, yt


def _scaling(x, y, grid):
    xmin = x.min()
    xmax = x.max()
    ymin = y.min()
    ymax = y.max()
    return np.mgrid[xmin:xmax:grid * 1j, ymin:ymax:grid * 1j]


def _profile(meshgrid_x, meshgrid_y):
    return meshgrid_x[:, 0], meshgrid_y[0, :]


def _position(meshgrid_x, meshgrid_y, trans_x, trans_y):
    positions = np.vstack([meshgrid_x.ravel(), meshgrid_y.ravel()])
    
    values = np.vstack([trans_x, trans_y])

    return positions, values


def _factor(rows, cols):
    return np.power(cols, -1. / (rows + 4))


def _weight(cols):
    return np.ones(cols) / cols
